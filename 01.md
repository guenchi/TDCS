# 1. 简介

Chez Scheme Version 1于1984年完成并于1985年发布。我惊讶地发现自己在二十多年后仍然在研究它。如果在1985年被问到期待二十年，我会说Chez Scheme和Scheme本身早就进入了历史的一段时间。毕竟，最古老的语言并不比今天的Scheme早，而且许多语言已经过去了。从那以后，许多语言都来去匆匆，但是根据大约1960年的Lisp，Scheme仍然存在。用户社区现在比以往更大，更多样化，所以运气好的话，语言和实现将持续至少二十年。这是一个可怕的想法。

长寿与适应性有关，目前Chez Scheme的版本与1985年的版本大不相同。它实现了更大，更不同的语言，体现了更丰富的编程环境。编译器和存储管理系统一样复杂得多。初始版本在一个架构上运行并在一个操作系统下运行，而系统现在支持各种不同的计算平台，并且一次又支持许多其他计算平台。

尽管如此，版本7背后的原理与第1版背后的原则相同。我们的主要目标仍然是可靠性和效率。可靠的系统是正确实现整个语言的系统，并且不会因编译器或运行时环境中的故障​​而崩溃。

一个高效的系统是在其操作的各个方面都表现出一致良好性能的系统，具有快速编译器，可以生成快速代码，并且可以实现最广泛的程序和编程风格。虽然我们多年来添加了许多新功能，并通过更好的反馈和调试支持来提高系统的可用性，但我们始终以考虑主要目标的方式这样做。

上面的段落首先出现在Chez Scheme Version 7用户指南[21]的序言中，该指南于2005年出版。当然，用户指南继续记录当前存在的语言，并且没有更多关于系统的历史。本文的目的是探索历史，回答系统如何以及为何成为现在的样子。

本文的其余部分首先简要介绍了这些系统，这些系统以某种方式是Chez Scheme的前身（第2节）。然后描述了Chez Scheme的初始版本和后续版本背后的动机以及这些版本中出现的一些更重要的新语言特性或实现技术（第3至10节）。本文最后提出了一些分离言论（第11节）。

# 2. 前言

Chez Scheme不是从真空中产生。 以下是我在Chez Scheme之前研究过的几个Scheme或Lisp系统的描述，这些系统以某种方式影响了Chez Scheme的设计和实现。

## 2.1 SDP

Scheme Distributed Processes [13]（SDP）是由印第安纳大学研究生Rex Dwyer和我在1980-81编写的Scheme的多线程实现。该系统主要是研究Per Brinch Hansen [34]提出的分布式过程并发模型的工具。它源于丹·弗里德曼（Dan Friedman）在他的研究生编程语言研讨会上给我们的任务，他用他和鲍勃·菲尔曼（Bob Filman）撰写的关于并发编程技术的书进行了教学[32]。

SDP支持1978年（修订报告）版本的大部分Scheme[52]。除了并行处理扩展外，SDP还支持数组，部分应用程序机制，用于加载和保存定义的dskin和dskout函数，甚至是结构编辑器。 SDP通过区分false和空列表以及要求列表的cdr也是列表来偏离Scheme的语义。 SDP完全是用Simura [3]编写的，并利用了Simula的运行时系统，其中最重要的是它的垃圾收集器。

虽然SDP的代码都没有存入我后来写的任何Scheme系统中，但它为我提供了我第一次使用Scheme和实现Lisp方言的经验。

## 2.2 Z80计划

1981年，当我在IU的学术计算中心担任系统程序员时，George Cohn和我决定为Z80微处理器创建Scheme的实现。通过这样做，乔治可以教我如何在Z80微处理器中编程，我可以教他Scheme。乔治是一个令人难以置信的程序员，我从他那里学到了很多东西，我确信这是讨价还价的最好结局。

我们在CP / M [48]操作系统下完全用Z80组装编码了Z80 Scheme系统。该系统支持大多数（如果不是全部）1978版本的方案，包括完整延续。所有值恰好占用32位（两个16位字）或由32位值的链接组成。所有对象在32位边界上对齐，我们能够使用每个单词的低位两位进行标记和垃圾收集。该系统被解释并包括一个简单的标记扫描收集器和自由列表分配器。

大约一年后，我们创建了Z80 Scheme系统的第二个版本，进行了两次重大更改。首先，我们将收集器转换为标记扫描紧凑型收集器，重新发明了显然由Daniel Edwards首先提出的“双指”压缩算法[49]。该算法实际上比原始算法运行得更快，并且它允许我们使用更快的内联分配。其次，我们取消了对完全延续的支持，以便我们可以使用传统的递归堆栈。因为堆栈和堆相互增长，所以压缩堆也可以确保在内存真正耗尽之前系统没有耗尽堆栈或堆空间。总的来说，这个系统比原来快得多，但我很遗憾失去对完整延续的支持。

我们还尝试了Z80 Scheme系统的编译器。我们设计了一个类似于Lisp 1.5 Lisp汇编语言（LAP）的方案汇编语言[45]，将其实现为一组库例程以节省代码空间，并从Scheme源生成了对这些库的一系列调用。例程。遗憾的是，由于库调用开销，系统运行速度并不比直接解释器快，并且生成的代码比原始源代码大，所以我们放弃了编译器。

## 2.3 C-Scheme
1982年，我也开始实施一种新方案Curry Scheme（后来缩写为C-Scheme）[14]。该系统采用预处理器，用Scheme编写，并通过Z80 Scheme系统启动。预处理器执行了宏扩展，并且还负责处理应用程序和lambda表达式。这是我第一次编写宏扩展器的经历，也是我第一次使用bootstrapping。运行时系统和解释器最初是在Z80上的Pascal中实现的，但后来在VAX上用C语言重新编码。存储管理系统采用存储器的大包页（Bi-BOP）表示，其中存储器被分解为固定大小的段，并且单独的段表用于识别每个段中包含的对象的类型[51]。 。通过分配两个或更多个连续段来支持大于段的对象。通过将虚拟内存地址空间的最低和最高部分留空并将相应的段表条目设置为fixnums的类型代码来支持未装箱的本机整数（fixnums）。

虽然Chez Scheme尚未构思，但C-Scheme是向Chez Scheme迈出的重要一步。 Chez Scheme的初始运行时系统大量借用了C-Scheme，而C-Scheme用于引导Chez Scheme编译器的第一个版本。


## 2.4 Data General Common Lisp
令人难以置信的巧合，我在1982年前往北卡罗来纳大学研究生院之前就碰到了丹·弗里德曼的办公室，当时三角研究园数据通用的Jed Harris打电话询问Dan是否知道任何可能感兴趣的人来北卡罗来纳州帮助他们发起Common Lisp的努力。丹把电话给我，杰德和我在安顿下来后安排见面。我作为一名合同雇员聘用了我自己作为整个DG Common Lisp小组服务了大约一年，Jed不时地越过我的肩膀查看（我的工作成果）。计划是将我为C-Scheme所做的工作调整为运行时系统，使用Common Lisp核心的解释器，然后在稍后的时间移植编译器。到今年年底，我已经用DG的专有系统编程语言编写了存储管理系统，I / O系统，解释器和各种原语。此时，其他几个人被聘用，Spice Lisp编译器从CMU引入，与运行时系统结合使用，我退回到偶尔的咨询，这样我就可以更多地关注我的博士研究。
在1984年的夏天，我被要求全职工作在DG修理存储管理系统，该系统已被替换为比原来慢两个数量级的存储管理系统，并在第二个收集周期中崩溃。简单地回到我之前的代码不是一个选项，因为现在添加了新的对象类型，并且其他一些代表的表示已经改变。此外，虽然我的旧（垃圾）收集器比它的速度快，但仍然很慢，花了一两分钟时间在DG的旗舰MV / 10000计算机上收集8MB的堆。 （别笑。我们有报道称除了DG以外的其他更慢的（垃圾）收集器。）所以我被要求做一个更快的（垃圾）收集器。不幸的是，直到7月底我还没有完成任务，因为DG计划在8月初的同一个Lisp和Functional Programming以及AAAI会议上演示他们的Common Lisp。另一方面，我获得了一个出色的合作伙伴Rob Vollum，这使得任务变得更加轻松，更加愉快。工作了18个小时，我们有一个坚实的存储管理系统，快速收集器及时进行演示。

我们通过将所有系统数据结构保留在所谓的堆的静态部分中而获得了大部分性能（但仍然在跟踪）。这是生成清除的一个很差的变种[43,45]，我还没有听说过，但它仍然相当有效。从C-Scheme继承的BiBOP表示允许我们避免跟踪不包含指针的段，例如包含字符串的段，并且我们也不经常收集这些段以避免在它们被页面调出时将它们带入内存。最终结果是收集器平均大约15秒收集8MB的堆 - 按照今天的标准非常慢，但当时可观。

从各方面来看，LFP和AAAI的演示都取得了成功。不幸的是，据我所知，DG内部的营销部门出价并赢得了销售Common Lisp产品的权利，此后不久获得了一份利润丰厚的合同，并且Common Lisp产品从未真正看到过光明的一天。然而，我从该项目中学到了很多东西，我能够在我的Chez Scheme工作中使用。除了获得有关存储管理的宝贵经验之外，我还记得DG对质量保证的认真态度以及对广泛测试套件开发的坚定信念印象深刻。此外，虽然我没有机会直接使用编译器，但我确实编写了处理lambda列表的代码，这是一项令人不快的任务，这有​​助于推动我在以后的几年中采用更简约的语言设计方法。

# 3. Chez Scheme Version 1

在1983年秋季和1984年春季DG的假期，我认真地为我的顾问（Gyula Mago）的蜂窝计算机[44]设计并行实施Scheme，这是我从我决定的那天起的意图。去UNC上学。由于实际上还没有机器，我也开始编写模拟器（自然地在Scheme中）。不幸的是，C-Scheme不够快，虽然它比我尝试的其他Scheme系统更快。我将模拟器移植到Franz Lisp [33]，这是一个很好的系统，但是由于它对函数参数的不良处理感到沮丧 - 编译器似乎对解释器的支持 - 以及编译器之间缺乏一致的语义 - 解释。因此，我决定与我的研究工作同时进行Scheme的编译器的设计和构建，最终成为Chez Scheme。

作为设计过程的一部分，我分析了C-Scheme的实现，发现大部分时间都花在了可变查找和堆栈帧创建上。我突然意识到Scheme的典型实现模型都是错误的：通过堆分配环境和调用框架，它以更常见的变量引用为代价快速创建闭包，并且它以更多的代价快速地进行延续操作通用程序调用。在我们的第二个Z80 Scheme实现中，我们选择牺牲完整的延续来实现堆栈帧的堆栈分配，并且T的设计者也做了同样的事[47]，但我不愿意采用Chez Scheme的那条路线。相反，我开始考虑如何使延续“按自己的方式付费”，同时将负担从闭合访问转移到闭包创建。

延续的解决方案似乎显而易见：使用堆栈进行过程调用，通过将堆栈复制到堆分配的数据结构来实现连续捕获，并通过将堆栈副本复制回堆栈来实现连续恢复。在环境仍然分配堆的情况下，变量值永远不会直接存储在堆栈中，并且不会担心制作可变变量的多个副本。另一方面，我的最终目标是使用传统的堆栈帧，其中局部变量存储在堆栈中，我不确定这是如何解决的。

解决关闭问题有点棘手。在研究其他系统如何应对类似问题时，我遇到了Brian Randell和Lawford Russell [46]关于Algol 60实现的书，该书描述了使用显示来加速访问本地函数的自由变量。显示器是一组存储器位置或寄存器，每个存储器位置或寄存器指向其变量构成当前词法环境的帧之一。显示器不能直接用于我的目的，但我能够进行多次调整，并从显示模型中派生出一个显示闭包的概念，一个堆分配的矢量类对象，其中包含一个代码指针和自由变量的值[16]。除了允许对所有变量进行恒定时间访问之外，它还具有额外的好处，即闭包不会占用环境而不是它们需要的环境，这有可能使垃圾收集更有效。

赋值变量是这种表示的一个问题，因为变量的值可能会出现在多个修饰中。我通过“装箱”分配变量来处理这个问题，即用指向堆分配的单细胞对象或装箱的指针替换每个赋值变量的值，并保持实际值。 （如果变量出现在其范围某处的分配的左侧，则假定变量被分配。）后来我了解到Luca Cardelli在他的ML实现中使用了类似的闭合平面表示[11] 。在ML中，变量是不可变的，因此编译器不需要引入装箱。可以将引入的装箱视为ML ref单元的一种形式，但不同之处在于，在ML中，程序员必须明确地引入ref单元，而在Scheme中，编译器隐式地引入装箱。

装箱分配的变量也解决了堆栈问题，因为它允许局部变量的值（或装箱值）直接存储在堆栈帧中，而不用担心由于连续捕获而可能复制帧的事实。

使用新的闭包和延续模型，创建闭包的成本与自由变量的数量成比例，但访问变量值的成本变得很小且恒定 - 如果没有赋值给变量，则需要一个内存参考能够出现在其范围内，否则两个。创建或恢复延续的成本与堆栈的大小成比例，但调用帧变为堆栈而不是堆分配，节省了链接开销，减少了垃圾收集的频率，并允许重用帧的公共部分当多次非尾调用时。分配变量的使用也变得更加昂贵，但是已经（并且应该）在Scheme中不经常使用分配的变量，因此这并不是很重要。最令人担忧的是尾部呼叫的正确处理可能会成本更高。被调用者的参数必须放在与调用者的局部变量相同的位置，以防止堆栈增长，但通常需要调用者的本地生成被调用者的参数。版本1中使用的简单解决方案是将被调用者的参数置于调用者的本地上方，并在将控制权转移给被调用者之前将其调低。

当我对新的封闭和延续模型感到兴奋时，我开发Chez Scheme的主要动机从构建用于我的研究的工具转变为证明我的新想法可用于构建快速可靠的Scheme实现供别人和我使用。因为我发现其他系统缺乏可靠性和速度，所以我重新集中精力建立一个不仅快速而且可靠的系统，包括完整的类型和边界检查，包括堆栈溢出检查，甚至在编译时也是如此码。新的焦点被证明是一个强大的激励因素，到1984年夏天，我有一个解决方案和运行时系统，其中大部分都是从C-Scheme复制而来，但是包含了从我的DG Common Lisp存储管理器中借来的想法。我还编写了编译器的前端，包括实现新模型所需的赋值和闭包转换过程。不幸的是，当Data General打电话给他们的存储管理器时，我不得不休息一下，直到那个秋天我才能再次工作。

当我在秋季回到Chez Scheme工作时，我支持运行时系统，在UNC研究生Bruce Smith的帮助下，添加了一个bignum算法包。这只剩下一个主要任务，编译后端的构造。我本来打算遵循Lisp的传统并提供一个交互式使用的翻译，但是Luca Cardelli访问并展示了他为ML制作的光滑的交互式增量编译器，我受到启发，为Chez Scheme走同样的路线。这使得后端更加困难，因为我无法使用系统汇编程序和链接程序，即使没有进程创建开销也会过慢，但是必须编写自己的程序集。最后，这些结果非常简单，但当时看起来是一个巨大的挑战，我把它推迟了很长一段时间。然而，最后，到1984年底，Chez Scheme的第1版已经完成。

编译器和运行时系统的部分是用Scheme编写的，并使用C-Scheme引导。运行时系统的其余部分是用C和汇编语言编写的。该系统仅支持一种架构，即VAX和一种操作系统BSD Unix。

从高级意义上讲，编译器是天真的。它处理了一小组核心形式，并且只做了一件可以称之为高级“优化：”的东西，它将直接lambda应用程序绑定的变量视为局部变量，以避免分配闭包和调用该变量的成本关闭。正如我现在告诉我的编译器学生，“优化”和“不是愚蠢的”之间存在一条界线。这实际上是后者的一个实例。

我的重点是低级细节，比如选择有效的表示和生成良好的指令序列，编译器确实包括一个窥视孔优化器。高级优化很重要，我们后来做了很多，但是低级细节通常具有更大的影响力，因为它们通常会影响更广泛的程序类，如果不是所有程序的话。

一个重要的表示方法是在每个符号中包含一个代码指针槽以及一个值槽，以提高对全局绑定过程（包括基元）的调用速度。通过维护一个单独的代码指针槽，全局调用通过该槽无条件地跳转，编译器不必生成过程？检查每次全球通话。在创建符号时将槽初始化，或者将其分配给陷阱处理程序的地址，该陷阱处理程序修补代码指针并完成调用（如果值是过程），或者发出错误信号，如果值未绑定或不是过程。在第一次成功调用之后，陷阱处理程序因此被绕过并且控制直接传递给被调用的过程。

可以将这个想法扩展到不同接口的多个代码指针，从而避免参数计数检查。我决定不在版本1中执行此操作有以下几个原因：（a）额外的代码指针会膨胀符号大小或需要使用辅助数据结构，（b）处理多个代码指针会增加编译器的复杂性和存储管理系统，（c）运行时间的节省会不那么重要，因为参数计数检查比类型检查便宜，后者涉及段表间接，以及（d）代码大小的节省将是不太重要，因为参数计数检查是在入口点而不是在呼叫站点进行的，并且呼叫站点通常比入口点更多。

这就是Chez Scheme决策的方式，特别是在早期。 我们采摘低悬的水果，这很容易，产生最大的节省，剩下的时间用于以后，如果有的话，继续选择其他树上的低悬果实。 当一个更容易获得更大利益的东西等待完成时，尝试在性能的一个方面实现完美是没有意义的。
虽然我现在不记得细节，但是版本1优于我可以访问的其他Scheme和Lisp系统，尽管有完整的类型和边界检查，所以我觉得新的闭包和延续表示已经证明了自己。 我在1985年春季通过UNC分发了6份版本1，用户的反馈也是积极的。

# 4. Chez Scheme Version 1.1

在1985年春季，布鲁斯史密斯和我创建了一个参考手册[31]。我将参考手册中的许多示例程序转换为测试套件的开头，然后通过许多其他测试扩充了测试套件。在此过程中我发现并修复了一些错误，并在夏季完成了系统的1.1版本。与此同时，我的妻子Susan Dybvig和我创立了Cadence Research Systems来分发和进一步开发该系统。 Susan的MBA学位以及之前与一家小型软件公司的经验补充了我的培训和经验，并且我们在夏天成功实现了1.1版的第一次商业发货。我们当时和之后的所有利润都经过再投资，以支付与发展相关的成本 - 主要是劳动力。

Susan还与Prentice-Hall签订了合同，以发布我们的参考手册。 Prentice-Hall选择了“计划编程语言”这一标题，显然是为了利用他们也发表的C编程语言[39]的成功。我很满意这一点，但它在我的脑海里大大提高了标准，最后我在1987年最终出版之前重写了大部分文本。不幸的是，我的合着者布鲁斯史密斯无法花太多时间在努力，我最终要求并获得他自己完成项目的许可。我永远感谢他对系统和书籍的早期重要贡献。

最初，我编写了所有的代码和文档，我们使用自制的Z80 PC来管理我们的业务，它配备8Mhz Z80H处理器，128K RAM和20MB硬盘，实际上比任何一个都要快。新的IBM PC，甚至是我在UNC使用过的VAX系统。 （公平地说，我已经定制了我的Gosling的Emacs副本来模拟Word88，这是我们在Z80上使用的单词处理系统。这大大减慢了Emacs的速度，并且可能解释了为什么VAX似乎变慢了。）构建和测试这是在北卡罗来纳州微电子中心（MCNC）的VAX计算机上完成的，作为交换，我们为Chez Scheme提供了免费许可。我们最终购买了一个Sun工作站并将我们的开发工作转移到该平台，我们不时购买或提供其他系统，但我们继续以客户为单位进行易货交易或借用时间进行构建并在我们所做的平台上进行测试没有内部。

我们购买的第一台Sun工作站是他们最低端的系统。我本来希望有一个更快的系统和更多的内存，当然，如果我们能够证明成本合理。另一方面，我认为让低端机器具有各种优势：如果我能让Chez Scheme运行良好，Chez Scheme在任何事情上都能运行良好。

|第1版亮点|
|-------|
|发行年份：1984（版本1。0），1985（版本1.1）

语言：R2RS兼容性，fixnums，bignums，比率，flonums，简单宏，保存的堆，保存的可执行文件，引擎[27,35]，跟踪支持，多个服务员和咖啡馆，原始宏系统，计时器和键盘中断，属性列表， 原始格式，动态风，流体绑定

实现：增量编译器（无解释器），自定义链接器，平面（“显示”）闭包，基于堆栈的控件表示，已分配变量的装箱，带保留（16位）fixnum范围的BiBOP类型，停止和复制收集器 ，代码指针缓存在符号代码指针槽中，窥孔优化

文档：Chez Scheme参考手册版本1.0 [31]，Unix手册页

平台：Vax BSD Unix|

