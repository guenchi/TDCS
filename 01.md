# 1. 简介

Chez Scheme Version 1于1984年完成并于1985年发布。我惊讶地发现自己在二十多年后仍然在研究它。如果在1985年被问到期待二十年，我会说Chez Scheme和Scheme本身早就进入了历史的一段时间。毕竟，最古老的语言并不比今天的Scheme早，而且许多语言已经过去了。从那以后，许多语言都来去匆匆，但是根据大约1960年的Lisp，Scheme仍然存在。用户社区现在比以往更大，更多样化，所以运气好的话，语言和实现将持续至少二十年。这是一个可怕的想法。

长寿与适应性有关，目前Chez Scheme的版本与1985年的版本大不相同。它实现了更大，更不同的语言，体现了更丰富的编程环境。编译器和存储管理系统一样复杂得多。初始版本在一个架构上运行并在一个操作系统下运行，而系统现在支持各种不同的计算平台，并且一次又支持许多其他计算平台。

尽管如此，版本7背后的原理与第1版背后的原则相同。我们的主要目标仍然是可靠性和效率。可靠的系统是正确实现整个语言的系统，并且不会因编译器或运行时环境中的故障​​而崩溃。

一个高效的系统是在其操作的各个方面都表现出一致良好性能的系统，具有快速编译器，可以生成快速代码，并且可以实现最广泛的程序和编程风格。虽然我们多年来添加了许多新功能，并通过更好的反馈和调试支持来提高系统的可用性，但我们始终以考虑主要目标的方式这样做。

上面的段落首先出现在Chez Scheme Version 7用户指南[21]的序言中，该指南于2005年出版。当然，用户指南继续记录当前存在的语言，并且没有更多关于系统的历史。本文的目的是探索历史，回答系统如何以及为何成为现在的样子。

本文的其余部分首先简要介绍了这些系统，这些系统以某种方式是Chez Scheme的前身（第2节）。然后描述了Chez Scheme的初始版本和后续版本背后的动机以及这些版本中出现的一些更重要的新语言特性或实现技术（第3至10节）。本文最后提出了一些分离言论（第11节）。

# 2. 前言

Chez Scheme不是从真空中产生。 以下是我在Chez Scheme之前研究过的几个Scheme或Lisp系统的描述，这些系统以某种方式影响了Chez Scheme的设计和实现。

## 2.1 SDP

Scheme Distributed Processes [13]（SDP）是由印第安纳大学研究生Rex Dwyer和我在1980-81编写的Scheme的多线程实现。该系统主要是研究Per Brinch Hansen [34]提出的分布式过程并发模型的工具。它源于丹·弗里德曼（Dan Friedman）在他的研究生编程语言研讨会上给我们的任务，他用他和鲍勃·菲尔曼（Bob Filman）撰写的关于并发编程技术的书进行了教学[32]。

SDP支持1978年（修订报告）版本的大部分Scheme[52]。除了并行处理扩展外，SDP还支持数组，部分应用程序机制，用于加载和保存定义的dskin和dskout函数，甚至是结构编辑器。 SDP通过区分false和空列表以及要求列表的cdr也是列表来偏离Scheme的语义。 SDP完全是用Simura [3]编写的，并利用了Simula的运行时系统，其中最重要的是它的垃圾收集器。

虽然SDP的代码都没有存入我后来写的任何Scheme系统中，但它为我提供了我第一次使用Scheme和实现Lisp方言的经验。

## 2.2 Z80计划

1981年，当我在IU的学术计算中心担任系统程序员时，George Cohn和我决定为Z80微处理器创建Scheme的实现。通过这样做，乔治可以教我如何在Z80微处理器中编程，我可以教他Scheme。乔治是一个令人难以置信的程序员，我从他那里学到了很多东西，我确信这是讨价还价的最好结局。

我们在CP / M [48]操作系统下完全用Z80组装编码了Z80 Scheme系统。该系统支持大多数（如果不是全部）1978版本的方案，包括完整延续。所有值恰好占用32位（两个16位字）或由32位值的链接组成。所有对象在32位边界上对齐，我们能够使用每个单词的低位两位进行标记和垃圾收集。该系统被解释并包括一个简单的标记扫描收集器和自由列表分配器。

大约一年后，我们创建了Z80 Scheme系统的第二个版本，进行了两次重大更改。首先，我们将收集器转换为标记扫描紧凑型收集器，重新发明了显然由Daniel Edwards首先提出的“双指”压缩算法[49]。该算法实际上比原始算法运行得更快，并且它允许我们使用更快的内联分配。其次，我们取消了对完全延续的支持，以便我们可以使用传统的递归堆栈。因为堆栈和堆相互增长，所以压缩堆也可以确保在内存真正耗尽之前系统没有耗尽堆栈或堆空间。总的来说，这个系统比原来快得多，但我很遗憾失去对完整延续的支持。

我们还尝试了Z80 Scheme系统的编译器。我们设计了一个类似于Lisp 1.5 Lisp汇编语言（LAP）的方案汇编语言[45]，将其实现为一组库例程以节省代码空间，并从Scheme源生成了对这些库的一系列调用。例程。遗憾的是，由于库调用开销，系统运行速度并不比直接解释器快，并且生成的代码比原始源代码大，所以我们放弃了编译器。

## 2.3 C-Scheme
1982年，我也开始实施一种新方案Curry Scheme（后来缩写为C-Scheme）[14]。该系统采用预处理器，用Scheme编写，并通过Z80 Scheme系统启动。预处理器执行了宏扩展，并且还负责处理应用程序和lambda表达式。这是我第一次编写宏扩展器的经历，也是我第一次使用bootstrapping。运行时系统和解释器最初是在Z80上的Pascal中实现的，但后来在VAX上用C语言重新编码。存储管理系统采用存储器的大包页（Bi-BOP）表示，其中存储器被分解为固定大小的段，并且单独的段表用于识别每个段中包含的对象的类型[51]。 。通过分配两个或更多个连续段来支持大于段的对象。通过将虚拟内存地址空间的最低和最高部分留空并将相应的段表条目设置为fixnums的类型代码来支持未装箱的本机整数（fixnums）。

虽然Chez Scheme尚未构思，但C-Scheme是向Chez Scheme迈出的重要一步。 Chez Scheme的初始运行时系统大量借用了C-Scheme，而C-Scheme用于引导Chez Scheme编译器的第一个版本。


## 2.4 Data General Common Lisp
令人难以置信的巧合，我在1982年前往北卡罗来纳大学研究生院之前就碰到了丹·弗里德曼的办公室，当时三角研究园数据通用的Jed Harris打电话询问Dan是否知道任何可能感兴趣的人来北卡罗来纳州帮助他们发起Common Lisp的努力。丹把电话给我，杰德和我在安顿下来后安排见面。我作为一名合同雇员聘用了我自己作为整个DG Common Lisp小组服务了大约一年，Jed不时地越过我的肩膀查看（我的工作成果）。计划是将我为C-Scheme所做的工作调整为运行时系统，使用Common Lisp核心的解释器，然后在稍后的时间移植编译器。到今年年底，我已经用DG的专有系统编程语言编写了存储管理系统，I / O系统，解释器和各种原语。此时，其他几个人被聘用，Spice Lisp编译器从CMU引入，与运行时系统结合使用，我退回到偶尔的咨询，这样我就可以更多地关注我的博士研究。
在1984年的夏天，我被要求全职工作在DG修理存储管理系统，该系统已被替换为比原来慢两个数量级的存储管理系统，并在第二个收集周期中崩溃。简单地回到我之前的代码不是一个选项，因为现在添加了新的对象类型，并且其他一些代表的表示已经改变。此外，虽然我的旧（垃圾）收集器比它的速度快，但仍然很慢，花了一两分钟时间在DG的旗舰MV / 10000计算机上收集8MB的堆。 （别笑。我们有报道称除了DG以外的其他更慢的（垃圾）收集器。）所以我被要求做一个更快的（垃圾）收集器。不幸的是，直到7月底我还没有完成任务，因为DG计划在8月初的同一个Lisp和Functional Programming以及AAAI会议上演示他们的Common Lisp。另一方面，我获得了一个出色的合作伙伴Rob Vollum，这使得任务变得更加轻松，更加愉快。工作了18个小时，我们有一个坚实的存储管理系统，快速收集器及时进行演示。

我们通过将所有系统数据结构保留在所谓的堆的静态部分中而获得了大部分性能（但仍然在跟踪）。这是生成清除的一个很差的变种[43,45]，我还没有听说过，但它仍然相当有效。从C-Scheme继承的BiBOP表示允许我们避免跟踪不包含指针的段，例如包含字符串的段，并且我们也不经常收集这些段以避免在它们被页面调出时将它们带入内存。最终结果是收集器平均大约15秒收集8MB的堆 - 按照今天的标准非常慢，但当时可观。

从各方面来看，LFP和AAAI的演示都取得了成功。不幸的是，据我所知，DG内部的营销部门出价并赢得了销售Common Lisp产品的权利，此后不久获得了一份利润丰厚的合同，并且Common Lisp产品从未真正看到过光明的一天。然而，我从该项目中学到了很多东西，我能够在我的Chez Scheme工作中使用。除了获得有关存储管理的宝贵经验之外，我还记得DG对质量保证的认真态度以及对广泛测试套件开发的坚定信念印象深刻。此外，虽然我没有机会直接使用编译器，但我确实编写了处理lambda列表的代码，这是一项令人不快的任务，这有​​助于推动我在以后的几年中采用更简约的语言设计方法。

# 3. Chez Scheme Version 1

在1983年秋季和1984年春季DG的假期，我认真地为我的顾问（Gyula Mago）的蜂窝计算机[44]设计并行实施Scheme，这是我从我决定的那天起的意图。去UNC上学。由于实际上还没有机器，我也开始编写模拟器（自然地在Scheme中）。不幸的是，C-Scheme不够快，虽然它比我尝试的其他Scheme系统更快。我将模拟器移植到Franz Lisp [33]，这是一个很好的系统，但是由于它对函数参数的不良处理感到沮丧 - 编译器似乎对解释器的支持 - 以及编译器之间缺乏一致的语义 - 解释。因此，我决定与我的研究工作同时进行Scheme的编译器的设计和构建，最终成为Chez Scheme。

作为设计过程的一部分，我分析了C-Scheme的实现，发现大部分时间都花在了可变查找和堆栈帧创建上。我突然意识到Scheme的典型实现模型都是错误的：通过堆分配环境和调用框架，它以更常见的变量引用为代价快速创建闭包，并且它以更多的代价快速地进行延续操作通用程序调用。在我们的第二个Z80 Scheme实现中，我们选择牺牲完整的延续来实现堆栈帧的堆栈分配，并且T的设计者也做了同样的事[47]，但我不愿意采用Chez Scheme的那条路线。相反，我开始考虑如何使延续“按自己的方式付费”，同时将负担从闭合访问转移到闭包创建。

延续的解决方案似乎显而易见：使用堆栈进行过程调用，通过将堆栈复制到堆分配的数据结构来实现连续捕获，并通过将堆栈副本复制回堆栈来实现连续恢复。在环境仍然分配堆的情况下，变量值永远不会直接存储在堆栈中，并且不会担心制作可变变量的多个副本。另一方面，我的最终目标是使用传统的堆栈帧，其中局部变量存储在堆栈中，我不确定这是如何解决的。

解决关闭问题有点棘手。在研究其他系统如何应对类似问题时，我遇到了Brian Randell和Lawford Russell [46]关于Algol 60实现的书，该书描述了使用显示来加速访问本地函数的自由变量。显示器是一组存储器位置或寄存器，每个存储器位置或寄存器指向其变量构成当前词法环境的帧之一。显示器不能直接用于我的目的，但我能够进行多次调整，并从显示模型中派生出一个显示闭包的概念，一个堆分配的矢量类对象，其中包含一个代码指针和自由变量的值[16]。除了允许对所有变量进行恒定时间访问之外，它还具有额外的好处，即闭包不会占用环境而不是它们需要的环境，这有可能使垃圾收集更有效。