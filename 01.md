# 1. 简介

Chez Scheme Version 1于1984年完成并于1985年发布。我惊讶地发现自己在二十多年后仍然在研究它。如果在1985年被问到期待二十年，我会说Chez Scheme和Scheme本身早就进入了历史的一段时间。毕竟，最古老的语言并不比今天的Scheme早，而且许多语言已经过去了。从那以后，许多语言都来去匆匆，但是根据大约1960年的Lisp，Scheme仍然存在。用户社区现在比以往更大，更多样化，所以运气好的话，语言和实现将持续至少二十年。这是一个可怕的想法。

长寿与适应性有关，目前Chez Scheme的版本与1985年的版本大不相同。它实现了更大，更不同的语言，体现了更丰富的编程环境。编译器和存储管理系统一样复杂得多。初始版本在一个架构上运行并在一个操作系统下运行，而系统现在支持各种不同的计算平台，并且一次又支持许多其他计算平台。

尽管如此，版本7背后的原理与第1版背后的原则相同。我们的主要目标仍然是可靠性和效率。可靠的系统是正确实现整个语言的系统，并且不会因编译器或运行时环境中的故障​​而崩溃。

一个高效的系统是在其操作的各个方面都表现出一致良好性能的系统，具有快速编译器，可以生成快速代码，并且可以实现最广泛的程序和编程风格。虽然我们多年来添加了许多新功能，并通过更好的反馈和调试支持来提高系统的可用性，但我们始终以考虑主要目标的方式这样做。

上面的段落首先出现在Chez Scheme Version 7用户指南[21]的序言中，该指南于2005年出版。当然，用户指南继续记录当前存在的语言，并且没有更多关于系统的历史。本文的目的是探索历史，回答系统如何以及为何成为现在的样子。

本文的其余部分首先简要介绍了这些系统，这些系统以某种方式是Chez Scheme的前身（第2节）。然后描述了Chez Scheme的初始版本和后续版本背后的动机以及这些版本中出现的一些更重要的新语言特性或实现技术（第3至10节）。本文最后提出了一些分离言论（第11节）。

# 2. 前言
Chez Scheme不是从真空中产生。 以下是我在Chez Scheme之前研究过的几个Scheme或Lisp系统的描述，这些系统以某种方式影响了Chez Scheme的设计和实现。

## 2.1 SDP
Scheme Distributed Processes [13]（SDP）是由印第安纳大学研究生Rex Dwyer和我在1980-81编写的Scheme的多线程实现。该系统主要是研究Per Brinch Hansen [34]提出的分布式过程并发模型的工具。它源于丹·弗里德曼（Dan Friedman）在他的研究生编程语言研讨会上给我们的任务，他用他和鲍勃·菲尔曼（Bob Filman）撰写的关于并发编程技术的书进行了教学[32]。
SDP支持1978年（修订报告）版本的大部分Scheme[52]。除了并行处理扩展外，SDP还支持数组，部分应用程序机制，用于加载和保存定义的dskin和dskout函数，甚至是结构编辑器。 SDP通过区分false和空列表以及要求列表的cdr也是列表来偏离Scheme的语义。 SDP完全是用Simura [3]编写的，并利用了Simula的运行时系统，其中最重要的是它的垃圾收集器。
虽然SDP的代码都没有存入我后来写的任何Scheme系统中，但它为我提供了我第一次使用Scheme和实现Lisp方言的经验。

## 2.2 Z80计划
1981年，当我在IU的学术计算中心担任系统程序员时，George Cohn和我决定为Z80微处理器创建Scheme的实现。通过这样做，乔治可以教我如何在Z80微处理器中编程，我可以教他Scheme。乔治是一个令人难以置信的程序员，我从他那里学到了很多东西，我确信这是讨价还价的最好结局。
我们在CP / M [48]操作系统下完全用Z80组装编码了Z80 Scheme系统。该系统支持大多数（如果不是全部）1978版本的方案，包括完整延续。所有值恰好占用32位（两个16位字）或由32位值的链接组成。所有对象在32位边界上对齐，我们能够使用每个单词的低位两位进行标记和垃圾收集。该系统被解释并包括一个简单的标记扫描收集器和自由列表分配器。
大约一年后，我们创建了Z80 Scheme系统的第二个版本，进行了两次重大更改。首先，我们将收集器转换为标记扫描紧凑型收集器，重新发明了显然由Daniel Edwards首先提出的“双指”压缩算法[49]。该算法实际上比原始算法运行得更快，并且它允许我们使用更快的内联分配。其次，我们取消了对完全延续的支持，以便我们可以使用传统的递归堆栈。因为堆栈和堆相互增长，所以压缩堆也可以确保在内存真正耗尽之前系统没有耗尽堆栈或堆空间。总的来说，这个系统比原来快得多，但我很遗憾失去对完整延续的支持。
我们还尝试了Z80 Scheme系统的编译器。我们设计了一个类似于Lisp 1.5 Lisp汇编语言（LAP）的方案汇编语言[45]，将其实现为一组库例程以节省代码空间，并从Scheme源生成了对这些库的一系列调用。例程。遗憾的是，由于库调用开销，系统运行速度并不比直接解释器快，并且生成的代码比原始源代码大，所以我们放弃了编译器。