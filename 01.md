# 1. 简介

Chez Scheme Version 1于1984年完成并于1985年发布。我惊讶地发现自己在二十多年后仍然在研究它。如果在1985年被问到期待二十年，我会说Chez Scheme和Scheme本身早就进入了历史的一段时间。毕竟，最古老的语言并不比今天的Scheme早，而且许多语言已经过去了。从那以后，许多语言都来去匆匆，但是根据大约1960年的Lisp，Scheme仍然存在。用户社区现在比以往更大，更多样化，所以运气好的话，语言和实现将持续至少二十年。这是一个可怕的想法。

长寿与适应性有关，目前Chez Scheme的版本与1985年的版本大不相同。它实现了更大，更不同的语言，体现了更丰富的编程环境。编译器和存储管理系统一样复杂得多。初始版本在一个架构上运行并在一个操作系统下运行，而系统现在支持各种不同的计算平台，并且一次又支持许多其他计算平台。

尽管如此，版本7背后的原理与第1版背后的原则相同。我们的主要目标仍然是可靠性和效率。可靠的系统是正确实现整个语言的系统，并且不会因编译器或运行时环境中的故障​​而崩溃。

一个高效的系统是在其操作的各个方面都表现出一致良好性能的系统，具有快速编译器，可以生成快速代码，并且可以实现最广泛的程序和编程风格。虽然我们多年来添加了许多新功能，并通过更好的反馈和调试支持来提高系统的可用性，但我们始终以考虑主要目标的方式这样做。

上面的段落首先出现在Chez Scheme Version 7用户指南[21]的序言中，该指南于2005年出版。当然，用户指南继续记录当前存在的语言，并且没有更多关于系统的历史。本文的目的是探索历史，回答系统如何以及为何成为现在的样子。

本文的其余部分首先简要介绍了这些系统，这些系统以某种方式是Chez Scheme的前身（第2节）。然后描述了Chez Scheme的初始版本和后续版本背后的动机以及这些版本中出现的一些更重要的新语言特性或实现技术（第3至10节）。本文最后提出了一些分离言论（第11节）。

# 2. 前言

Chez Scheme不是从真空中产生。 以下是我在Chez Scheme之前研究过的几个Scheme或Lisp系统的描述，这些系统以某种方式影响了Chez Scheme的设计和实现。

## 2.1 SDP

Scheme Distributed Processes [13]（SDP）是由印第安纳大学研究生Rex Dwyer和我在1980-81编写的Scheme的多线程实现。该系统主要是研究Per Brinch Hansen [34]提出的分布式过程并发模型的工具。它源于丹·弗里德曼（Dan Friedman）在他的研究生编程语言研讨会上给我们的任务，他用他和鲍勃·菲尔曼（Bob Filman）撰写的关于并发编程技术的书进行了教学[32]。

SDP支持1978年（修订报告）版本的大部分Scheme[52]。除了并行处理扩展外，SDP还支持数组，部分应用程序机制，用于加载和保存定义的dskin和dskout函数，甚至是结构编辑器。 SDP通过区分false和空列表以及要求列表的cdr也是列表来偏离Scheme的语义。 SDP完全是用Simura [3]编写的，并利用了Simula的运行时系统，其中最重要的是它的垃圾收集器。

虽然SDP的代码都没有存入我后来写的任何Scheme系统中，但它为我提供了我第一次使用Scheme和实现Lisp方言的经验。

## 2.2 Z80计划

1981年，当我在IU的学术计算中心担任系统程序员时，George Cohn和我决定为Z80微处理器创建Scheme的实现。通过这样做，乔治可以教我如何在Z80微处理器中编程，我可以教他Scheme。乔治是一个令人难以置信的程序员，我从他那里学到了很多东西，我确信这是讨价还价的最好结局。

我们在CP / M [48]操作系统下完全用Z80组装编码了Z80 Scheme系统。该系统支持大多数（如果不是全部）1978版本的方案，包括完整延续。所有值恰好占用32位（两个16位字）或由32位值的链接组成。所有对象在32位边界上对齐，我们能够使用每个单词的低位两位进行标记和垃圾收集。该系统被解释并包括一个简单的标记扫描收集器和自由列表分配器。

大约一年后，我们创建了Z80 Scheme系统的第二个版本，进行了两次重大更改。首先，我们将收集器转换为标记扫描紧凑型收集器，重新发明了显然由Daniel Edwards首先提出的“双指”压缩算法[49]。该算法实际上比原始算法运行得更快，并且它允许我们使用更快的内联分配。其次，我们取消了对完全延续的支持，以便我们可以使用传统的递归堆栈。因为堆栈和堆相互增长，所以压缩堆也可以确保在内存真正耗尽之前系统没有耗尽堆栈或堆空间。总的来说，这个系统比原来快得多，但我很遗憾失去对完整延续的支持。

我们还尝试了Z80 Scheme系统的编译器。我们设计了一个类似于Lisp 1.5 Lisp汇编语言（LAP）的方案汇编语言[45]，将其实现为一组库例程以节省代码空间，并从Scheme源生成了对这些库的一系列调用。例程。遗憾的是，由于库调用开销，系统运行速度并不比直接解释器快，并且生成的代码比原始源代码大，所以我们放弃了编译器。

## 2.3 C-Scheme
1982年，我也开始实施一种新方案Curry Scheme（后来缩写为C-Scheme）[14]。该系统采用预处理器，用Scheme编写，并通过Z80 Scheme系统启动。预处理器执行了宏扩展，并且还负责处理应用程序和lambda表达式。这是我第一次编写宏扩展器的经历，也是我第一次使用bootstrapping。运行时系统和解释器最初是在Z80上的Pascal中实现的，但后来在VAX上用C语言重新编码。存储管理系统采用存储器的大包页（Bi-BOP）表示，其中存储器被分解为固定大小的段，并且单独的段表用于识别每个段中包含的对象的类型[51]。 。通过分配两个或更多个连续段来支持大于段的对象。通过将虚拟内存地址空间的最低和最高部分留空并将相应的段表条目设置为fixnums的类型代码来支持未装箱的本机整数（fixnums）。

虽然Chez Scheme尚未构思，但C-Scheme是向Chez Scheme迈出的重要一步。 Chez Scheme的初始运行时系统大量借用了C-Scheme，而C-Scheme用于引导Chez Scheme编译器的第一个版本。


## 2.4 Data General Common Lisp
令人难以置信的巧合，我在1982年前往北卡罗来纳大学研究生院之前就碰到了丹·弗里德曼的办公室，当时三角研究园数据通用的Jed Harris打电话询问Dan是否知道任何可能感兴趣的人来北卡罗来纳州帮助他们发起Common Lisp的努力。丹把电话给我，杰德和我在安顿下来后安排见面。我作为一名合同雇员聘用了我自己作为整个DG Common Lisp小组服务了大约一年，Jed不时地越过我的肩膀查看（我的工作成果）。计划是将我为C-Scheme所做的工作调整为运行时系统，使用Common Lisp核心的解释器，然后在稍后的时间移植编译器。到今年年底，我已经用DG的专有系统编程语言编写了存储管理系统，I / O系统，解释器和各种原语。此时，其他几个人被聘用，Spice Lisp编译器从CMU引入，与运行时系统结合使用，我退回到偶尔的咨询，这样我就可以更多地关注我的博士研究。
在1984年的夏天，我被要求全职工作在DG修理存储管理系统，该系统已被替换为比原来慢两个数量级的存储管理系统，并在第二个收集周期中崩溃。简单地回到我之前的代码不是一个选项，因为现在添加了新的对象类型，并且其他一些代表的表示已经改变。此外，虽然我的旧（垃圾）收集器比它的速度快，但仍然很慢，花了一两分钟时间在DG的旗舰MV / 10000计算机上收集8MB的堆。 （别笑。我们有报道称除了DG以外的其他更慢的（垃圾）收集器。）所以我被要求做一个更快的（垃圾）收集器。不幸的是，直到7月底我还没有完成任务，因为DG计划在8月初的同一个Lisp和Functional Programming以及AAAI会议上演示他们的Common Lisp。另一方面，我获得了一个出色的合作伙伴Rob Vollum，这使得任务变得更加轻松，更加愉快。工作了18个小时，我们有一个坚实的存储管理系统，快速收集器及时进行演示。

我们通过将所有系统数据结构保留在所谓的堆的静态部分中而获得了大部分性能（但仍然在跟踪）。这是生成清除的一个很差的变种[43,45]，我还没有听说过，但它仍然相当有效。从C-Scheme继承的BiBOP表示允许我们避免跟踪不包含指针的段，例如包含字符串的段，并且我们也不经常收集这些段以避免在它们被页面调出时将它们带入内存。最终结果是收集器平均大约15秒收集8MB的堆 - 按照今天的标准非常慢，但当时可观。

从各方面来看，LFP和AAAI的演示都取得了成功。不幸的是，据我所知，DG内部的营销部门出价并赢得了销售Common Lisp产品的权利，此后不久获得了一份利润丰厚的合同，并且Common Lisp产品从未真正看到过光明的一天。然而，我从该项目中学到了很多东西，我能够在我的Chez Scheme工作中使用。除了获得有关存储管理的宝贵经验之外，我还记得DG对质量保证的认真态度以及对广泛测试套件开发的坚定信念印象深刻。此外，虽然我没有机会直接使用编译器，但我确实编写了处理lambda列表的代码，这是一项令人不快的任务，这有​​助于推动我在以后的几年中采用更简约的语言设计方法。

# 3. Chez Scheme Version 1

在1983年秋季和1984年春季DG的假期，我认真地为我的顾问（Gyula Mago）的蜂窝计算机[44]设计并行实施Scheme，这是我从我决定的那天起的意图。去UNC上学。由于实际上还没有机器，我也开始编写模拟器（自然地在Scheme中）。不幸的是，C-Scheme不够快，虽然它比我尝试的其他Scheme系统更快。我将模拟器移植到Franz Lisp [33]，这是一个很好的系统，但是由于它对函数参数的不良处理感到沮丧 - 编译器似乎对解释器的支持 - 以及编译器之间缺乏一致的语义 - 解释。因此，我决定与我的研究工作同时进行Scheme的编译器的设计和构建，最终成为Chez Scheme。

作为设计过程的一部分，我分析了C-Scheme的实现，发现大部分时间都花在了可变查找和堆栈帧创建上。我突然意识到Scheme的典型实现模型都是错误的：通过堆分配环境和调用框架，它以更常见的变量引用为代价快速创建闭包，并且它以更多的代价快速地进行延续操作通用程序调用。在我们的第二个Z80 Scheme实现中，我们选择牺牲完整的延续来实现堆栈帧的堆栈分配，并且T的设计者也做了同样的事[47]，但我不愿意采用Chez Scheme的那条路线。相反，我开始考虑如何使延续“按自己的方式付费”，同时将负担从闭合访问转移到闭包创建。

延续的解决方案似乎显而易见：使用堆栈进行过程调用，通过将堆栈复制到堆分配的数据结构来实现连续捕获，并通过将堆栈副本复制回堆栈来实现连续恢复。在环境仍然分配堆的情况下，变量值永远不会直接存储在堆栈中，并且不会担心制作可变变量的多个副本。另一方面，我的最终目标是使用传统的堆栈帧，其中局部变量存储在堆栈中，我不确定这是如何解决的。

解决关闭问题有点棘手。在研究其他系统如何应对类似问题时，我遇到了Brian Randell和Lawford Russell [46]关于Algol 60实现的书，该书描述了使用显示来加速访问本地函数的自由变量。显示器是一组存储器位置或寄存器，每个存储器位置或寄存器指向其变量构成当前词法环境的帧之一。显示器不能直接用于我的目的，但我能够进行多次调整，并从显示模型中派生出一个显示闭包的概念，一个堆分配的矢量类对象，其中包含一个代码指针和自由变量的值[16]。除了允许对所有变量进行恒定时间访问之外，它还具有额外的好处，即闭包不会占用环境而不是它们需要的环境，这有可能使垃圾收集更有效。

赋值变量是这种表示的一个问题，因为变量的值可能会出现在多个修饰中。我通过“装箱”分配变量来处理这个问题，即用指向堆分配的单细胞对象或装箱的指针替换每个赋值变量的值，并保持实际值。 （如果变量出现在其范围某处的分配的左侧，则假定变量被分配。）后来我了解到Luca Cardelli在他的ML实现中使用了类似的闭合平面表示[11] 。在ML中，变量是不可变的，因此编译器不需要引入装箱。可以将引入的装箱视为ML ref单元的一种形式，但不同之处在于，在ML中，程序员必须明确地引入ref单元，而在Scheme中，编译器隐式地引入装箱。

装箱分配的变量也解决了堆栈问题，因为它允许局部变量的值（或装箱值）直接存储在堆栈帧中，而不用担心由于连续捕获而可能复制帧的事实。

使用新的闭包和延续模型，创建闭包的成本与自由变量的数量成比例，但访问变量值的成本变得很小且恒定 - 如果没有赋值给变量，则需要一个内存参考能够出现在其范围内，否则两个。创建或恢复延续的成本与堆栈的大小成比例，但调用帧变为堆栈而不是堆分配，节省了链接开销，减少了垃圾收集的频率，并允许重用帧的公共部分当多次非尾调用时。分配变量的使用也变得更加昂贵，但是已经（并且应该）在Scheme中不经常使用分配的变量，因此这并不是很重要。最令人担忧的是尾部呼叫的正确处理可能会成本更高。被调用者的参数必须放在与调用者的局部变量相同的位置，以防止堆栈增长，但通常需要调用者的本地生成被调用者的参数。版本1中使用的简单解决方案是将被调用者的参数置于调用者的本地上方，并在将控制权转移给被调用者之前将其调低。

当我对新的封闭和延续模型感到兴奋时，我开发Chez Scheme的主要动机从构建用于我的研究的工具转变为证明我的新想法可用于构建快速可靠的Scheme实现供别人和我使用。因为我发现其他系统缺乏可靠性和速度，所以我重新集中精力建立一个不仅快速而且可靠的系统，包括完整的类型和边界检查，包括堆栈溢出检查，甚至在编译时也是如此码。新的焦点被证明是一个强大的激励因素，到1984年夏天，我有一个解决方案和运行时系统，其中大部分都是从C-Scheme复制而来，但是包含了从我的DG Common Lisp存储管理器中借来的想法。我还编写了编译器的前端，包括实现新模型所需的赋值和闭包转换过程。不幸的是，当Data General打电话给他们的存储管理器时，我不得不休息一下，直到那个秋天我才能再次工作。

当我在秋季回到Chez Scheme工作时，我支持运行时系统，在UNC研究生Bruce Smith的帮助下，添加了一个bignum算法包。这只剩下一个主要任务，编译后端的构造。我本来打算遵循Lisp的传统并提供一个交互式使用的翻译，但是Luca Cardelli访问并展示了他为ML制作的光滑的交互式增量编译器，我受到启发，为Chez Scheme走同样的路线。这使得后端更加困难，因为我无法使用系统汇编程序和链接程序，即使没有进程创建开销也会过慢，但是必须编写自己的程序集。最后，这些结果非常简单，但当时看起来是一个巨大的挑战，我把它推迟了很长一段时间。然而，最后，到1984年底，Chez Scheme的第1版已经完成。

编译器和运行时系统的部分是用Scheme编写的，并使用C-Scheme引导。运行时系统的其余部分是用C和汇编语言编写的。该系统仅支持一种架构，即VAX和一种操作系统BSD Unix。

从高级意义上讲，编译器是天真的。它处理了一小组核心形式，并且只做了一件可以称之为高级“优化：”的东西，它将直接lambda应用程序绑定的变量视为局部变量，以避免分配闭包和调用该变量的成本关闭。正如我现在告诉我的编译器学生，“优化”和“不是愚蠢的”之间存在一条界线。这实际上是后者的一个实例。

我的重点是低级细节，比如选择有效的表示和生成良好的指令序列，编译器确实包括一个窥视孔优化器。高级优化很重要，我们后来做了很多，但是低级细节通常具有更大的影响力，因为它们通常会影响更广泛的程序类，如果不是所有程序的话。

一个重要的表示方法是在每个符号中包含一个代码指针槽以及一个值槽，以提高对全局绑定过程（包括基元）的调用速度。通过维护一个单独的代码指针槽，全局调用通过该槽无条件地跳转，编译器不必生成过程？检查每次全球通话。在创建符号时将槽初始化，或者将其分配给陷阱处理程序的地址，该陷阱处理程序修补代码指针并完成调用（如果值是过程），或者发出错误信号，如果值未绑定或不是过程。在第一次成功调用之后，陷阱处理程序因此被绕过并且控制直接传递给被调用的过程。

可以将这个想法扩展到不同接口的多个代码指针，从而避免参数计数检查。我决定不在版本1中执行此操作有以下几个原因：（a）额外的代码指针会膨胀符号大小或需要使用辅助数据结构，（b）处理多个代码指针会增加编译器的复杂性和存储管理系统，（c）运行时间的节省会不那么重要，因为参数计数检查比类型检查便宜，后者涉及段表间接，以及（d）代码大小的节省将是不太重要，因为参数计数检查是在入口点而不是在呼叫站点进行的，并且呼叫站点通常比入口点更多。

这就是Chez Scheme决策的方式，特别是在早期。 我们采摘低悬的水果，这很容易，产生最大的节省，剩下的时间用于以后，如果有的话，继续选择其他树上的低悬果实。 当一个更容易获得更大利益的东西等待完成时，尝试在性能的一个方面实现完美是没有意义的。
虽然我现在不记得细节，但是版本1优于我可以访问的其他Scheme和Lisp系统，尽管有完整的类型和边界检查，所以我觉得新的闭包和延续表示已经证明了自己。 我在1985年春季通过UNC分发了6份版本1，用户的反馈也是积极的。

# 4. Chez Scheme Version 1.1

在1985年春季，布鲁斯史密斯和我创建了一个参考手册[31]。我将参考手册中的许多示例程序转换为测试套件的开头，然后通过许多其他测试扩充了测试套件。在此过程中我发现并修复了一些错误，并在夏季完成了系统的1.1版本。与此同时，我的妻子Susan Dybvig和我创立了Cadence Research Systems来分发和进一步开发该系统。 Susan的MBA学位以及之前与一家小型软件公司的经验补充了我的培训和经验，并且我们在夏天成功实现了1.1版的第一次商业发货。我们当时和之后的所有利润都经过再投资，以支付与发展相关的成本 - 主要是劳动力。

Susan还与Prentice-Hall签订了合同，以发布我们的参考手册。 Prentice-Hall选择了“计划编程语言”这一标题，显然是为了利用他们也发表的C编程语言[39]的成功。我很满意这一点，但它在我的脑海里大大提高了标准，最后我在1987年最终出版之前重写了大部分文本。不幸的是，我的合着者布鲁斯史密斯无法花太多时间在努力，我最终要求并获得他自己完成项目的许可。我永远感谢他对系统和书籍的早期重要贡献。

最初，我编写了所有的代码和文档，我们使用自制的Z80 PC来管理我们的业务，它配备8Mhz Z80H处理器，128K RAM和20MB硬盘，实际上比任何一个都要快。新的IBM PC，甚至是我在UNC使用过的VAX系统。 （公平地说，我已经定制了我的Gosling的Emacs副本来模拟Word88，这是我们在Z80上使用的单词处理系统。这大大减慢了Emacs的速度，并且可能解释了为什么VAX似乎变慢了。）构建和测试这是在北卡罗来纳州微电子中心（MCNC）的VAX计算机上完成的，作为交换，我们为Chez Scheme提供了免费许可。我们最终购买了一个Sun工作站并将我们的开发工作转移到该平台，我们不时购买或提供其他系统，但我们继续以客户为单位进行易货交易或借用时间进行构建并在我们所做的平台上进行测试没有内部。

我们购买的第一台Sun工作站是他们最低端的系统。我本来希望有一个更快的系统和更多的内存，当然，如果我们能够证明成本合理。另一方面，我认为让低端机器具有各种优势：如果我能让Chez Scheme运行良好，Chez Scheme在任何事情上都能运行良好。

|第1版亮点|
|-------|
|发行年份：1984(版本1.0),1985(版本1.1)|
|语言：R2RS兼容性，fixnums，bignums，比率，flonums，简单宏，保存的堆，保存的可执行文件，引擎[27,35]，跟踪支持，多个服务员和咖啡馆，原始宏系统，计时器和键盘中断，属性列表， 原始格式，动态风，流体绑定|
|实现：增量编译器（无解释器），自定义链接器，平面（“显示”）闭包，基于堆栈的控件表示，已分配变量的装箱，带保留（16位）fixnum范围的BiBOP类型，停止和复制收集器 ，代码指针缓存在符号代码指针槽中，窥孔优化|
|文档：Chez Scheme参考手册版本1.0 [31]，Unix手册页|
|平台：Vax BSD Unix|


# 5. Chez Scheme Version 2

1985年秋天，我们搬到印第安纳州布卢明顿，在那里我加入了印第安纳大学的教师队伍。在学年期间，我完成了开发工作，同时我准备并教授了一整年的编译课程和另一门课程。然而，在春季学期的某个时候，桑迪亚国家实验室的George Davidson曾使用过Chez Scheme几个月，他们要求我们创建一个从VAX到嵌入式MC68000系统的交叉编译器。这是一个很好的机会，可以使用MC68000代码生成器，后来我们可以将系统移植到Sun，Apollo和其他几个平台上。我决定从我的编译器课程中聘请一名研究生来帮助我度过这个项目。

编译器课程中充满了非常优秀的学生，但其中一个在其他学生中脱颖而出（字面上和形象上都是如此）。 Bob Hieb身高6英尺6英寸，宽肩，浓密的头发，留着浓密的胡须，尖锐的特征，以及由法兰绒衬衫，牛仔裤和靴子组成的典型服装。他看起来更像一个伐木工人而不是一个计算机科学家（我后来才知道他已经花了十年时间作为木匠），但他在课堂上的表现显示出巨大的潜力，所以我给了他这份工作。他很高兴地接受了，并且在他1992年不幸去世之前，我们最终共同工作了七年。

在完成MC68000交叉编译器之后，Bob和我一起研究了实现的其他方面。我们实现了不同的优化级别，这些级别实际上只是标志告诉编译器它可以做某些事情。在优化级别1，允许花费更多时间。在优化级别2，允许假设基元的全局名称确实绑定到那些基元。在优化级别3，允许生成不安全的代码。我们还在编译器中引入了一些代码来优化letrec表达式，优化循环和内联大多数简单的原语
由于编译器在Scheme中编码并在引导后从其自身的优化中受益，因此这些改进使编译器本身更快。实际上，优化不仅弥补了编译器为实现优化所做的额外工作。这是一件好事，因为我们担心编译器速度（编译器毕竟是交互式使用和加载源文件）以及有效性。在某些时候，我们实际上制定了以下规则以限制编译开销：如果优化不能使编译器本身足够快以弥补执行优化的成本，则优化将被丢弃。这排除了我们尝试的几个优化，包括早期尝试源优化器。

我们还在收集器上工作，看看我们是否可以改善其性能。在算法方面有很小的选择，这已经和我们知道如何制作一样紧。但是，通过将关键例程定义为C预处理器宏而不是C函数，我们能够从“10％到33％的改进”中获取（根据代码中的注释）。

除了移植和加快系统工作外，我们还采用了一些新的语言功能，包括支持低级扩展传递式宏定义[24,25]和高级扩展语法宏定义[41] 。直到很久以后我们才采用卫生宏观扩张[41,42]，因为二次扩张成本以及我们直到很久以后才解决的机制的其他局限性。

我们还添加了一个用于创建“可变arity”过程的新功能，即具有多个接口的过程，可选参数的泛化。 case-lambda表达式类似于lambda表达式，但有多个子句将形式参数列表与正文配对。当调用使用case-lambda创建的过程时，将根据接收的实际参数数选择相应的子句。我们的原始设计要求使用不同的语法替换点接口，允许一个或多个案例接受无限数量的参数而不承诺对这些参数的任何特定表示。这有效地从界面中删除了列表，以及列表可以通过优化对无限期程序的调用而导致的各种困难[26,28]。我们退回了这个功能，而是选择了一个不那么激进的版本，其中每个子句的形式参数列表是一个普通的lambda形式参数列表。

版本2于1987年发布，与Prentice-Hall出版的The Scheme Programming Language大致相同。

# 6. Chez Scheme Version 3

在版本2和版本3的版本之间，我们继续调整编译器和运行时系统以提高性能，但我们大部分时间都花在移植上用于一对新的RISC架构，从而提高了Chez Scheme与其他语言的互操作性和流程，并提高系统的整体可用性。

改善性能和可用性的一个变化是采用了新的延续机制。在版本1和版本2中，捕获延续意味着复制整个堆栈，并重新启动延续意味着将其全部复制回来，这意味着延续操作可能变得非常昂贵。我们用一种新的分段堆栈方法解决了这个问题，鲍勃和我与另一位毕业生Carl Bruggeman一起开发了这种方法[36]。这种机制消除了在捕获延续时复制堆栈的需要，并且在恢复延续时减少复制到少量恒定字数（或最多为最大帧的大小）的数量，而不添加任何开销正常的过程调用和返回。该机制还支持自动堆栈溢出恢复，只要堆空间仍然可用于分配，堆栈空间永远不会耗尽。

通过好运而不是设计，新的延续机制还使我们能够根据Olivier Danvy的请求修改跟踪包，以反映非尾部调用之间的差异（通过增加跟踪显示嵌套级别和显示返回值）和尾调用（两者都没有）。挑战在于识别对跟踪过程的哪些调用是非尾调用，哪些调用是尾调用，最初我们感到难过。如果跟踪包被内置到解释器中，则解释器可以跟踪此信息，但我们没有解释器。相反，跟踪包通过将每个跟踪过程嵌入另一个过程来操作，该过程是一个负责打印跟踪信息的跟踪包装器。解决方案是跟踪包以维护跟踪连续变量，该变量始终保持最后一个跟踪调用的延续。每个跟踪包装器将其自身的延续与跟踪延续进行比较。如果它们相同，则发生尾调用，如果它们不同，则发生非尾调用。对于非尾部调用，跟踪包装器在应用嵌入式过程之前将跟踪延续设置为新的当前延续，并在之后恢复旧的跟踪延续。使用continuation的分段堆栈表示，可以使用单个eq? test进行连续的比较，即指针比较。

我们的第一个RISC移植是摩托罗拉MC88000，是在摩托罗拉的Sam Daniel的要求下完成的，摩托罗拉多年来一直支持摩托罗拉的Chez Scheme，甚至设法说服摩托罗拉在其Delta系列MC68000和MC88000系列上销售Chez Scheme机器一会儿。 MC88000是我们承担的最困难的移植之一，在一个夏天的大部分时间里，我花了三个人的共同努力（我招募了Carl和Bob一起帮忙）。部分原因是它的RISC架构与CISC VAX和MC68000架构完全不同，但主要是因为操作系统，C编译器甚至硬件在移植时仍处于活跃开发阶段。当然，这意味着要处理几个编译器和操作系统错误，但最大的挑战是硬件错误。一个是挑战，部分是因为它在我们设置断点或单步执行代码时进入隐藏状态。事实证明这是一个竞争条件，在从硬件返回地址寄存器移动到我们自己的返回地址寄存器中时缺少记分板（忙）检查。当我们从断点开始或单步执行代码时，寄存器不再繁忙，我们的代码运行没有问题。但是，当全速运行时，我们的代码偶尔会尝试过早访问寄存器，而不是被迫等待，会得到错误的（旧）值，通常会导致程序返回（最终）给调用者的调用者而不是自己的调用者。

另一个移植是Sparc架构，而且更顺畅，因为我们已经移植到一个RISC架构，操作系统基本上与MC68000 Sun系统相同，工具和硬件更稳定。在同一过程中与其他流程和其他语言的互操作性是我们的一些用户的优先事项。这促使我们添加了用于加载外部目标文件和在这些文件中输入入口点的工具，并自动将语言和返回值数据类型转换为C和Scheme表示。这些工具是在其他Lisp方言的实现中的类似特征之后建模的。我们还添加了对子进程中运行其他程序以及通过Unix管道与它们进行交互的支持。

我们为版本3和所有其他新版本编写的大多数新代码都是用Scheme编写的，而一些最初用C编写的代码已经转换为Scheme，它可以在更多代码中编写抽象风格不太可能受系统变化的影响，例如，对象表示。我们在使用版本3时转换的最大代码是Chez Scheme阅读器，它实现了Scheme读取过程，并在加载或编译源程序时使用。我们期望读者会有点慢，但不足以证明让读者留在C中。尽管Scheme版本使用了相互尾递归的例程，但是Scheme编码的读者实际上变得更快了。词汇分析，而C语言的时间关键部分在循环时使用。虽然差异可能部分是由于我们可以相对容易地调整Scheme代码，但很高兴知道Chez Scheme的编译器开始达到可以与C编译器竞争的程度，C编译器具有更容易完成的工作。当我们对寄存器分配进行了重大改进，包括将寄存器分配给过程参数时，Scheme编码的读取器在下一版本中变得更快。版本3于1989年发布。